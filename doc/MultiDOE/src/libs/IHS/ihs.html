<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ihs</title>
  <meta name="keywords" content="ihs">
  <meta name="description" content="*****************************************************************************80">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../../menu.html MultiDOE --><!-- # src --><!-- ../menu.html libs --><!-- menu.html IHS -->
<h1>ihs
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>*****************************************************************************80</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function x = ihs ( dim_num, point_num, duplication ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">*****************************************************************************80

% IHS implements the improved distributed hypercube sampling algorithm.

  Discussion:

    N Points in an M dimensional Latin hypercube are to be selected.
    Each of the M coordinate dimensions is discretized to the values
    1 through N.  The points are to be chosen in such a way that
    no two points have any coordinate value in common.  This is
    a standard Latin hypercube requirement, and there are many
    solutions.

    This algorithm differs in that it tries to pick a solution
    which has the property that the points are &quot;spread out&quot;
    as evenly as possible.  It does this by determining an optimal
    even spacing, and using the DUPLICATION factor to allow it
    to choose the best of the various options available to it.

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    27 February 2014

  Author:

    John Burkardt
    Improvements by Jeremy Dewar, Tulane University.

  Reference:

    Brian Beachkofski, Ramana Grandhi,
    Improved Distributed Hypercube Sampling,
    American Institute of Aeronautics and Astronautics Paper 2002-1274.

  Parameters:

    Input, integer DIM_NUM, the spatial dimension.

    Input, integer POINT_NUM, the number of points to be generated.

    Input, integer DUPLICATION, the duplication factor.  This must
    be at least 1.  A value of 5 is reasonable.

    Output, integer X(DIM_NUM,POINT_NUM), the points.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="../../../../MultiDOE/README.html" class="code" title="">README</a>	</li><li><a href="ihs_test01.html" class="code" title="function ihs_test01 ( )">ihs_test01</a>	*****************************************************************************80</li><li><a href="ihs_test02.html" class="code" title="function ihs_test02 ( )">ihs_test02</a>	*****************************************************************************80</li><li><a href="ihs_test03.html" class="code" title="function ihs_test03 ( )">ihs_test03</a>	*****************************************************************************80</li><li><a href="ihs_test04.html" class="code" title="function ihs_test04 ( )">ihs_test04</a>	*****************************************************************************80</li><li><a href="../../../../MultiDOE/src/various/buildDOE.html" class="code" title="function [sampling]=buildDOE(type,ns,Xmin,Xmax,opts)">buildDOE</a>	% Building sampling</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function x = ihs ( dim_num, point_num, duplication )</a>
0002 
0003 <span class="comment">%*****************************************************************************80</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%% IHS implements the improved distributed hypercube sampling algorithm.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%  Discussion:</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%    N Points in an M dimensional Latin hypercube are to be selected.</span>
0010 <span class="comment">%    Each of the M coordinate dimensions is discretized to the values</span>
0011 <span class="comment">%    1 through N.  The points are to be chosen in such a way that</span>
0012 <span class="comment">%    no two points have any coordinate value in common.  This is</span>
0013 <span class="comment">%    a standard Latin hypercube requirement, and there are many</span>
0014 <span class="comment">%    solutions.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%    This algorithm differs in that it tries to pick a solution</span>
0017 <span class="comment">%    which has the property that the points are &quot;spread out&quot;</span>
0018 <span class="comment">%    as evenly as possible.  It does this by determining an optimal</span>
0019 <span class="comment">%    even spacing, and using the DUPLICATION factor to allow it</span>
0020 <span class="comment">%    to choose the best of the various options available to it.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%  Licensing:</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%    This code is distributed under the GNU LGPL license.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%  Modified:</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%    27 February 2014</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%  Author:</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%    John Burkardt</span>
0033 <span class="comment">%    Improvements by Jeremy Dewar, Tulane University.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%  Reference:</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%    Brian Beachkofski, Ramana Grandhi,</span>
0038 <span class="comment">%    Improved Distributed Hypercube Sampling,</span>
0039 <span class="comment">%    American Institute of Aeronautics and Astronautics Paper 2002-1274.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%  Parameters:</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%    Input, integer DIM_NUM, the spatial dimension.</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%    Input, integer POINT_NUM, the number of points to be generated.</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%    Input, integer DUPLICATION, the duplication factor.  This must</span>
0048 <span class="comment">%    be at least 1.  A value of 5 is reasonable.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%    Output, integer X(DIM_NUM,POINT_NUM), the points.</span>
0051 <span class="comment">%</span>
0052   opt = point_num / point_num^( 1.0 / dim_num );
0053 <span class="comment">%</span>
0054 <span class="comment">%  Pick the first point.</span>
0055 <span class="comment">%</span>
0056   x = zeros ( dim_num, point_num );
0057 
0058   x(:,point_num) = randi ( point_num, [dim_num,1] );
0059 <span class="comment">%</span>
0060 <span class="comment">%  Initialize AVAIL,</span>
0061 <span class="comment">%  and set an entry in a random row of each column of AVAIL to POINT_NUM.</span>
0062 <span class="comment">%</span>
0063   avail = zeros(dim_num, point_num);
0064   <span class="keyword">for</span> j = 1 : point_num
0065     avail(1:dim_num,j) = j;
0066   <span class="keyword">end</span>
0067 
0068   <span class="keyword">for</span> i = 1 : dim_num
0069     avail(i,x(i,point_num)) = point_num;
0070   <span class="keyword">end</span>
0071 <span class="comment">%</span>
0072 <span class="comment">%  Main loop:</span>
0073 <span class="comment">%  Assign a value to X(1:DIM_NUM,COUNT) for COUNT = POINT_NUM-1 down to 2.</span>
0074 <span class="comment">%</span>
0075   <span class="keyword">for</span> count = point_num-1 : -1 : 2
0076 <span class="comment">%</span>
0077 <span class="comment">%  Generate valid points.</span>
0078 <span class="comment">%</span>
0079     <span class="keyword">for</span> i = 1 : dim_num
0080 
0081       <span class="keyword">for</span> k = 1 : duplication
0082         list(count*(k-1)+1:k*count) = avail(i,1:count);
0083       <span class="keyword">end</span>
0084 
0085       point_idxs = randi ( k, [1,count*duplication] );
0086       <span class="keyword">for</span> k = count*duplication : -1 : 1
0087         pk = point_idxs(k);
0088         point(i,k) = list(pk);
0089         list(pk) = list(k);
0090       <span class="keyword">end</span>
0091 
0092     <span class="keyword">end</span>
0093 <span class="comment">%</span>
0094 <span class="comment">%  For each candidate, determine the distance to all the</span>
0095 <span class="comment">%  points that have already been selected, and save the minimum value.</span>
0096 <span class="comment">%</span>
0097     min_all = realmax;
0098     best = 0;
0099 
0100     <span class="keyword">for</span> k = 1 : duplication*count
0101 
0102       min_can = realmax;
0103 
0104       <span class="keyword">for</span> j = count+1 : point_num
0105         dist = norm(point(:,k) - x(:,j));
0106         min_can = min ( min_can, dist );
0107       <span class="keyword">end</span>
0108 
0109       <span class="keyword">if</span> ( abs ( min_can - opt ) &lt; min_all )
0110         min_all = abs ( min_can - opt );
0111         best = k;
0112       <span class="keyword">end</span>
0113 
0114     <span class="keyword">end</span>
0115 
0116     x(1:dim_num,count) = point(1:dim_num,best);
0117 <span class="comment">%</span>
0118 <span class="comment">%  Having chosen X(*,COUNT), update AVAIL.</span>
0119 <span class="comment">%</span>
0120     <span class="keyword">for</span> i = 1 : dim_num
0121 
0122       <span class="keyword">for</span> j = 1 : point_num
0123         <span class="keyword">if</span> ( avail(i,j) == x(i,count) )
0124           avail(i,j) = avail(i,count);
0125         <span class="keyword">end</span>
0126       <span class="keyword">end</span>
0127 
0128     <span class="keyword">end</span>
0129 
0130   <span class="keyword">end</span>
0131 <span class="comment">%</span>
0132 <span class="comment">%  For the last point, there's only one choice.</span>
0133 <span class="comment">%</span>
0134   x(1:dim_num,1) = avail(1:dim_num,1);
0135 
0136   <span class="keyword">return</span>
0137 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 12-Sep-2016 18:05:54 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>