<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mchol</title>
  <meta name="keywords" content="mchol">
  <meta name="description" content="[L,D,E,pneg]=mchol1(G)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../../menu.html MultiDOE --><!-- # src --><!-- ../menu.html libs --><!-- menu.html LHS -->
<h1>mchol
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>[L,D,E,pneg]=mchol1(G)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [L,D,E,pneg]=mchol(G) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">
  [L,D,E,pneg]=mchol1(G)

  Given a symmetric matrix G, find a matrix E of &quot;small&quot; norm and c
  L, and D such that  G+E is Positive Definite, and 

      G+E = L*D*L'

  Also, calculate a direction pneg, such that if G is not PD, then

      pneg'*G*pneg &lt; 0

  Note that if G is PD, then the routine will return pneg=[]. 

  Reference: Gill, Murray, and Wright, &quot;Practical Optimization&quot;, p111.
  Author: Brian Borchers (borchers@nmt.edu)


  n gives the size of the matrix.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="lhs_iman_n.html" class="code" title="function z=lhs_iman_n(xmean,xsd,corr,nsample,ntry)">lhs_iman_n</a>	z=lhs_iman_n(xmean,xsd,corr,nsample,ntry)</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%</span>
0002 <span class="comment">%  [L,D,E,pneg]=mchol1(G)</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%  Given a symmetric matrix G, find a matrix E of &quot;small&quot; norm and c</span>
0005 <span class="comment">%  L, and D such that  G+E is Positive Definite, and</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%      G+E = L*D*L'</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%  Also, calculate a direction pneg, such that if G is not PD, then</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%      pneg'*G*pneg &lt; 0</span>
0012 <span class="comment">%</span>
0013 <span class="comment">%  Note that if G is PD, then the routine will return pneg=[].</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%  Reference: Gill, Murray, and Wright, &quot;Practical Optimization&quot;, p111.</span>
0016 <span class="comment">%  Author: Brian Borchers (borchers@nmt.edu)</span>
0017 <span class="comment">%</span>
0018 <a name="_sub0" href="#_subfunctions" class="code">function [L,D,E,pneg]=mchol(G)</a>
0019 <span class="comment">%</span>
0020 <span class="comment">%  n gives the size of the matrix.</span>
0021 <span class="comment">%</span>
0022 n=size(G,1);
0023 <span class="comment">%</span>
0024 <span class="comment">%  gamma, zi, nu, and beta2 are quantities used by the algorithm.</span>
0025 <span class="comment">%</span>
0026 gamma=max(diag(G));
0027 zi=max(max(G-diag(diag(G))));
0028 nu=max([1,sqrt(n^2-1)]);
0029 beta2=max([gamma, zi/nu, 1.0E-15]);
0030 <span class="comment">%</span>
0031 <span class="comment">%  Initialize diag(C) to diag(G).</span>
0032 <span class="comment">%</span>
0033 C=diag(diag(G));
0034 <span class="comment">%</span>
0035 <span class="comment">%  Loop through, calculating column j of L for j=1:n</span>
0036 <span class="comment">%</span>
0037 
0038 L=zeros(n);
0039 D=zeros(n);
0040 E=zeros(n);
0041 
0042 <span class="keyword">for</span> j=1:n,
0043     bb=[1:j-1];
0044     ee=[j+1:n];
0045 
0046     <span class="comment">%</span>
0047     <span class="comment">%  Calculate the jth row of L.</span>
0048     <span class="comment">%</span>
0049     <span class="keyword">if</span> (j &gt; 1),
0050         L(j,bb)=C(j,bb)./diag(D(bb,bb))';
0051     <span class="keyword">end</span>;
0052     <span class="comment">%</span>
0053     <span class="comment">%  Update the jth column of C.</span>
0054     <span class="comment">%</span>
0055     <span class="keyword">if</span> (j &gt;= 2),
0056         <span class="keyword">if</span> (j &lt; n), 
0057             C(ee,j)=G(ee,j)-(L(j,bb)*C(ee,bb)')';
0058         <span class="keyword">end</span>;
0059     <span class="keyword">else</span>
0060         C(ee,j)=G(ee,j);
0061     <span class="keyword">end</span>;
0062     <span class="comment">%</span>
0063     <span class="comment">% Update theta.</span>
0064     <span class="comment">%</span>
0065     <span class="keyword">if</span> (j == n)
0066         theta(j)=0;
0067     <span class="keyword">else</span>
0068         theta(j)=max(abs(C(ee,j)));
0069     <span class="keyword">end</span>;
0070     <span class="comment">%</span>
0071     <span class="comment">%  Update D</span>
0072     <span class="comment">%</span>
0073     D(j,j)=max([eps,abs(C(j,j)),theta(j)^2/beta2]');
0074     <span class="comment">%</span>
0075     <span class="comment">% Update E.</span>
0076     <span class="comment">%</span>
0077     E(j,j)=D(j,j)-C(j,j);
0078 
0079     
0080     <span class="comment">%</span>
0081     <span class="comment">%  Update C again...</span>
0082     <span class="comment">%</span>
0083     <span class="comment">%%%%%%%% M.Zibulevsky: begin of changes, old version is commented %%%%%%%%%%%%%</span>
0084     
0085     <span class="comment">%for i=j+1:n,</span>
0086     <span class="comment">%    C(i,i)=C(i,i)-C(i,j)^2/D(j,j);</span>
0087     <span class="comment">%end;</span>
0088     
0089     ind=[j*(n+1)+1 : n+1 : n*n]';
0090     C(ind)=C(ind)-(1/D(j,j))*C(ee,j).^2;
0091 
0092 
0093 <span class="keyword">end</span>;
0094 
0095 <span class="comment">%</span>
0096 <span class="comment">% Put 1's on the diagonal of L</span>
0097 <span class="comment">%</span>
0098 <span class="comment">%for j=1:n,</span>
0099 <span class="comment">%    L(j,j)=1;</span>
0100 <span class="comment">%end;</span>
0101 
0102 ind=[1 : n+1 : n*n]';
0103 L(ind)=1;
0104 
0105 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% M.Zibulevsky: end of changes %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0106 
0107 <span class="comment">%</span>
0108 <span class="comment">%  if needed, find a descent direction.</span>
0109 <span class="comment">%</span>
0110 <span class="keyword">if</span> ((nargout == 4) &amp; (min(diag(C)) &lt; 0.0))
0111     [m,col]=min(diag(C));
0112     rhs=zeros(n,1);
0113     rhs(col)=1;
0114     pneg=L'\rhs;
0115 <span class="keyword">else</span>
0116   pneg=[];
0117 <span class="keyword">end</span>;
0118 
0119 
0120 <span class="keyword">return</span>
0121 
0122 
0123 
0124 
0125 
0126</pre></div>
<hr><address>Generated on Tue 17-Jan-2017 22:42:52 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>