<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ltqnorm</title>
  <meta name="keywords" content="ltqnorm">
  <meta name="description" content="LTQNORM Lower tail quantile for standard normal distribution.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../../menu.html MultiDOE --><!-- # src --><!-- ../menu.html libs --><!-- menu.html LHS -->
<h1>ltqnorm
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>LTQNORM Lower tail quantile for standard normal distribution.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function z = ltqnorm(p) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">LTQNORM Lower tail quantile for standard normal distribution.

   Z = LTQNORM(P) returns the lower tail quantile for the standard normal
   distribution function.  I.e., it returns the Z satisfying Pr{X &lt; Z} = P,
   where X has a standard normal distribution.

   LTQNORM(P) is the same as SQRT(2) * ERFINV(2*P-1), but the former returns a
   more accurate value when P is close to zero.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="latin_hs.html" class="code" title="function s=latin_hs(xmean,xsd,nsample,nvar)">latin_hs</a>	s=latin_hs(xmean,xsd,nsample,nvar)</li><li><a href="lhs_stein.html" class="code" title="function z=lhs_stein(xmean,xsd,corr,nsample,ntry)">lhs_stein</a>	z=lhs_stein(xmean,xsd,corr,nsample)</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function z = ltqnorm(p)</a>
0002 <span class="comment">%LTQNORM Lower tail quantile for standard normal distribution.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   Z = LTQNORM(P) returns the lower tail quantile for the standard normal</span>
0005 <span class="comment">%   distribution function.  I.e., it returns the Z satisfying Pr{X &lt; Z} = P,</span>
0006 <span class="comment">%   where X has a standard normal distribution.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%   LTQNORM(P) is the same as SQRT(2) * ERFINV(2*P-1), but the former returns a</span>
0009 <span class="comment">%   more accurate value when P is close to zero.</span>
0010 
0011 <span class="comment">%   The algorithm uses a minimax approximation by rational functions and the</span>
0012 <span class="comment">%   result has a relative error less than 1.15e-9.  A last refinement by</span>
0013 <span class="comment">%   Halley's rational method is applied to achieve full machine precision.</span>
0014 
0015 <span class="comment">%   Author:      Peter J. Acklam</span>
0016 <span class="comment">%   Time-stamp:  2003-04-23 08:26:51 +0200</span>
0017 <span class="comment">%   E-mail:      pjacklam@online.no</span>
0018 <span class="comment">%   URL:         http://home.online.no/~pjacklam</span>
0019 
0020    <span class="comment">% Coefficients in rational approximations.</span>
0021    a = [ -3.969683028665376e+01  2.209460984245205e+02 <span class="keyword">...</span>
0022          -2.759285104469687e+02  1.383577518672690e+02 <span class="keyword">...</span>
0023          -3.066479806614716e+01  2.506628277459239e+00 ];
0024    b = [ -5.447609879822406e+01  1.615858368580409e+02 <span class="keyword">...</span>
0025          -1.556989798598866e+02  6.680131188771972e+01 <span class="keyword">...</span>
0026          -1.328068155288572e+01 ];
0027    c = [ -7.784894002430293e-03 -3.223964580411365e-01 <span class="keyword">...</span>
0028          -2.400758277161838e+00 -2.549732539343734e+00 <span class="keyword">...</span>
0029          4.374664141464968e+00  2.938163982698783e+00 ];
0030    d = [  7.784695709041462e-03  3.224671290700398e-01 <span class="keyword">...</span>
0031           2.445134137142996e+00  3.754408661907416e+00 ];
0032 
0033    <span class="comment">% Define break-points.</span>
0034    plow  = 0.02425;
0035    phigh = 1 - plow;
0036 
0037    <span class="comment">% Initialize output array.</span>
0038    z = zeros(size(p));
0039 
0040    <span class="comment">% Rational approximation for central region:</span>
0041    k = plow &lt;= p &amp; p &lt;= phigh;
0042    <span class="keyword">if</span> any(k(:))
0043       q = p(k) - 0.5;
0044       r = q.*q;
0045       z(k) = (((((a(1)*r+a(2)).*r+a(3)).*r+a(4)).*r+a(5)).*r+a(6)).*q ./ <span class="keyword">...</span>
0046              (((((b(1)*r+b(2)).*r+b(3)).*r+b(4)).*r+b(5)).*r+1);
0047    <span class="keyword">end</span>
0048 
0049    <span class="comment">% Rational approximation for lower region:</span>
0050    k = 0 &lt; p &amp; p &lt; plow;
0051    <span class="keyword">if</span> any(k(:))
0052       q  = sqrt(-2*log(p(k)));
0053       z(k) = (((((c(1)*q+c(2)).*q+c(3)).*q+c(4)).*q+c(5)).*q+c(6)) ./ <span class="keyword">...</span>
0054              ((((d(1)*q+d(2)).*q+d(3)).*q+d(4)).*q+1);
0055    <span class="keyword">end</span>
0056 
0057    <span class="comment">% Rational approximation for upper region:</span>
0058    k = phigh &lt; p &amp; p &lt; 1;
0059    <span class="keyword">if</span> any(k(:))
0060       q  = sqrt(-2*log(1-p(k)));
0061       z(k) = -(((((c(1)*q+c(2)).*q+c(3)).*q+c(4)).*q+c(5)).*q+c(6)) ./ <span class="keyword">...</span>
0062              ((((d(1)*q+d(2)).*q+d(3)).*q+d(4)).*q+1);
0063    <span class="keyword">end</span>
0064 
0065    <span class="comment">% Case when P = 0:</span>
0066    z(p == 0) = -Inf;
0067 
0068    <span class="comment">% Case when P = 1:</span>
0069    z(p == 1) = Inf;
0070 
0071    <span class="comment">% Cases when output will be NaN:</span>
0072    k = p &lt; 0 | p &gt; 1 | isnan(p);
0073    <span class="keyword">if</span> any(k(:))
0074       z(k) = NaN;
0075    <span class="keyword">end</span>
0076 
0077    <span class="comment">% The relative error of the approximation has absolute value less</span>
0078    <span class="comment">% than 1.15e-9.  One iteration of Halley's rational method (third</span>
0079    <span class="comment">% order) gives full machine precision.</span>
0080    k = 0 &lt; p &amp; p &lt; 1;
0081    <span class="keyword">if</span> any(k(:))
0082       e = 0.5*erfc(-z(k)/sqrt(2)) - p(k);          <span class="comment">% error</span>
0083       u = e * sqrt(2*pi) .* exp(z(k).^2/2);        <span class="comment">% f(z)/df(z)</span>
0084       <span class="comment">%z(k) = z(k) - u;                             % Newton's method</span>
0085       z(k) = z(k) - u./( 1 + z(k).*u/2 );          <span class="comment">% Halley's method</span>
0086    <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 02-Jun-2016 11:32:25 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>